#
# Test::System
#
# Author(s): Pablo Fischer (pfischer@cpan.org)
# Created: 11/07/2009 17:36:17 PST 17:36:17
package Test::System;

=head1 NAME

Test::System - Test suite oriented for testing a *system*

=head1 SYNOPSIS

    use Test::System;

    my $suite = Test::System->new(
            format => 'consoletable',
            nodes => 'example.com',
            tests_yaml => '~/code/my/system/tests.yaml'
            );
    $hung->runtests;

=head1 DESCRIPTION

Loads and runs the available tests cases located in the namespace of
Seco::Insanity::Tests. User can specify if only one or a group of tests cases
should be run.

=cut

use Moose; # it turns strict and warnings
use File::Basename qw(dirname);
use YAML::Syck;
use Test::System::Output::Factory;
use TAP::Harness;
use Data::Dumper;

=head1 Attributes

Test::System exports a number of attributes that some only have read only
access and others allow write access.

=over 6

=item B<tests_yaml>

YAML filename of where a list of available tests are. You probably want to take
a look to C<examples/tests.yaml> but a quick example is:

    ping:
        description: Test the ping and do foo and make bar
        code: test/foo.pl
    cpu:
        description: Test the CPU of nodes
        code: test/cpu.pl

=cut
has 'tests_yaml' => (
        is => 'rw',
        isa => 'Str',
        required => 1,
        trigger => \&_read_tests_yaml_file
        );

=item B<tests_dir>

Read only attribute generated by the read of the YAML file. Its value is the
directory path of where C<tests_yaml> is located.

=cut
has 'tests_dir' => (
        is => 'ro',
        isa => 'Str'
        );

=item B<available_tests>

Is a read only attribute that contains a list of all available tests found in
the YAML file provided by tests_yaml.

=cut
has 'available_tests' => (
        is => 'ro',
        isa => => 'ArrayRef[Str]',
        );

=item B<nodes>

Is an attribute that can be represented as a string (like a hostname) or as a
list (where each item will be a node/hostname). This attribute has write access
and is where the tests are going to be executed to.

=cut
has 'nodes' => (
        is => 'rw',
        isa => 'Any',
        required => 1,
        trigger => \&_verify_nodes_datatype
        );

=item B<format>

A write access string that has the format of how the tests should be presented,
please refer to the modules available under Test::System::Output

=cut
has 'format' => (
        is => 'rw',
        isa => 'Str',
        default => 'console',
        trigger => \&_verify_format
        );

=item B<available_formats>

A list of available formats, read only.

=cut
has 'available_formats' => (
        is => 'ro',
        isa => => 'HashRef',
        default => \&_generate_output_types_hash
        );

=item B<parameters>

An attribute with write access permission. This attribute will transform all
the items of this hash to environment variables.

The use of this attribute is very handy if you want to provide some additional
data for your tests and since the tests are run in separate forks with
Test::Harness then the only possible way to keep them is to make them available
through the environment (C<%ENV> hash).

Please be warned that only scalars are stored in environment variables, those
that are an array will be converted to CSV values while the rest of the data
types will be lost.

In your tests if you want to use any of these parameters they will be available
through the environment variables with a prefix of: I<TEST_SYSTEM_>.

=cut
has 'parameters' => (
        is => 'rw',
        isa => 'HashRef[Str]',
        );

=back

=head1 Methods

=over 4

=item B<runtests( @tests , %options)>

It will run a group of given test cases, however if no list is given or is
empty then all the available cases will be run.

The C<%options> is a hash of options that will be passed to the B<TAP::Harness>
object, some useful parameters are:

=over 4

=item * verbosity

By default we mute everything with C<-9>.

=item * color

If you want the output (in console) to have color

=item * formatter

Although we use B<Test::System::Output::Factory> to offer a set of formatters
you can provide your own formatter object.

=item * jobs

If you have many tests you probably want to increment this value (that defaults
to C<1>) so other tests can be run at the same time.

=back

=cut
sub runtests {
    my ($self, $tests, $options) = @_;
    my @tests_to_run = keys(%{$self->available_tests}) unless
        scalar $tests eq 0;
    # No duplicate tests and build the module name
    my (%seen, @test_files);
    foreach (@tests_to_run) {
        if (!$seen{$_}++) {
            # Does the test exist?
            if (!defined $self->available_tests->{$_}) {
                warn "$_ does not appear on $self->yaml_file";
            } else {
                if (!defined $self->available_tests->{$_}->{'code'}) {
                    warn "No code was defined for $_ on $self->yaml_file";
                } else {
                    my $description = uc $_;
                    if (defined $self->available_tests->{$_}->{'description'}) {
                        $description = $self->available_tests->{$_}->{'description'};
                    }
                    push(@test_files, [
                            $self->available_tests->{$_}->{'code'},
                            $description]);
                }
            }
        }
    }
    $self->prepare_environment();
    my $formatter_class = Test::System::Output::Factory->get_registered_class(
            $self->format
            );
    if (!defined $options->{'formatter_class'} && !defined $options->{'formatter'}) {
        $options->{'formatter_class'} = $formatter_class;
    }
    $options->{'merge'} = 0 unless defined $options->{'merge'};
    my $verbosity = -9;
    if (defined $options->{'verbosity'}) {
        $verbosity = $options->{'verbosity'};
        delete $options->{'verbosity'};
    }
    my $harness = TAP::Harness->new($options);
    $harness->formatter->verbosity($verbosity);
    $harness->runtests(@test_files);
    $self->clean_environment();
    return 1;
}

=item B<prepare_environment>

Prepares the environment by settings the needed environment values so they can
be used later by the tests

=cut
sub prepare_environment {
    my ($self) = @_;

    # Nodes are stored under the TEST_SYSTEM_NODES environment key
    $ENV{TEST_SYSTEM_NODES} = $self->nodes;
    if ($self->parameters) {
        if (ref \$self->parameters eq 'HASH') {
            foreach my $k (keys %{$self->parameters}) {
                # We are very cautious with environments variables already set
                $k = uc $k;
                if (!$ENV{'TEST_SYSTEM_' . $k}) {
                    my $value = $self->parameters->{$k};
                    if (ref \$value eq 'SCALAR') {
                        $ENV{'TEST_SYSTEM_' . $k} = $value;
                    } elsif (ref \$value eq 'ARRAY') {
                        $ENV{'TEST_SYSTEM_' . $k} = join(',', $value);
                    }
                }
            }
        }
    }
}

=item B<clean_environment>

Cleans/deletes all the environment variables that match I<TEST_SYSTEM_*>

=cut
sub clean_environment {
    my ($self) = @_;

    my %environment_vars = %ENV;
    foreach my $k (%environment_vars) {
        if ($k =~ /^TEST_SYSTEM_/) {
            delete $ENV{$k};
        }
    }
}

################################# Triggers ##################################
# Trigger for test_dir, when test_dir gets modified we look for all tests
# available in the given directory and so on we populate/fill the tests list
# attribute
sub _read_tests_yaml_file {
    my ($self, $yaml_file) = @_;
    
    if (!-f $yaml_file) {
        confess "The YAML file ($yaml_file) does not exist";
    }

    $self->{tests_yaml} = $yaml_file;
    $self->{tests_dir} = dirname($yaml_file);

    my $tests = LoadFile($yaml_file);
    foreach my $test (keys %$tests) {
        if (defined $tests->{$test}->{'code'}) {
            my $code = $tests->{$test}->{'code'};
            if (!-f $code) {
                $tests->{$test}->{'code'} = $self->{tests_dir} . '/' . $code;
            }
        }
    }
    $self->{available_tests} = $tests;
}

# Trigger for nodes, when nodes gets modified we don't really know if its
# a string or a list (and this is because we accept both) so we should make sure
# of what we get and validate it.
sub _verify_nodes_datatype {
    my ($self, $nodes) = @_;

    if (ref \$nodes eq 'ARRAY') {
        $self->{nodes} = join(',', $nodes);
    } else {
        $self->{nodes} = $nodes;
    }
}

# Trigger for format, when format gets modified we want to make sure the format
# is valid
sub _verify_format {
    my ($self, $format) = @_;

    if (!defined $self->available_formats->{$format}) {
        confess "The format you provided ($format) is not valid";
    }

    $self->{format} = $format;
}

# Generates the output type hash reference by checking the registered factory
# types of Test::System::Output::Factory
sub _generate_output_types_hash {
    my ($self) = @_;

    my @registered_types = Test::System::Output::Factory->get_registered_types;

    my %hash;
    foreach (@registered_types) {
        $hash{$_} = 1;
    }
    return \%hash;
}

1;

